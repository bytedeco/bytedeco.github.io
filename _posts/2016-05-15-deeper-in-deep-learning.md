---
layout: post
title: Going deeper into deep learning
---

After more than half a year, we are finally making a release! You can obtain the new version 1.2 at the usual places on GitHub and the Maven Central Repository for [JavaCPP](https://github.com/bytedeco/javacpp), [JavaCPP Presets](https://github.com/bytedeco/javacpp-presets), [JavaCV](https://github.com/bytedeco/javacv), [ProCamCalib](https://github.com/bytedeco/procamcalib), and [ProCamTracker](https://github.com/bytedeco/procamtracker). For Scala users, Lloyd Chan has also contributed [sbt-javacpp](https://github.com/bytedeco/sbt-javacpp) and [sbt-javacv](https://github.com/bytedeco/sbt-javacv), offering them easy-to-use plugins for sbt. Thanks to Vince Baines, this release also contains a few binaries for the `linux-armhf` platform, which work on most Raspberry Pi devices, among others. We also hope to have continuous integration (CI) set up before long to provide a larger selection of prebuilt binaries on all platforms for non-release versions as well.

With regards to deep learning, we realized last year that JavaCPP had the characteristics of something that was in demand especially in that field, that is to say an easy way to access native libraries from an efficient platform like Java: [Java meets Caffe, deep learning in perspective]({% post_url 2015-03-14-java-meets-caffe %}). Since then, Samuel has switched jobs and now works for [Skymind](http://www.skymind.io/), integrating [JavaCPP](https://github.com/bytedeco/javacpp), the [JavaCPP Presets](https://github.com/bytedeco/javacpp-presets), and [JavaCV](https://github.com/bytedeco/javacv) into [ND4J](https://github.com/deeplearning4j/nd4j) and [Deeplearning4j](https://github.com/deeplearning4j/deeplearning4j), as well as pursuing other avenues, such as maintaining not only [bindings for Caffe](https://github.com/bytedeco/javacpp-presets/tree/master/caffe) and [cuDNN](https://github.com/bytedeco/javacpp-presets/tree/master/cuda), but also for [MXNet](https://github.com/bytedeco/javacpp-presets/tree/master/mxnet) and [TensorFlow](https://github.com/bytedeco/javacpp-presets/tree/master/tensorflow), among others. Many thanks to Adam Gibson and Chris Nicholson for their trust! I am sure we will achieve great things together.

That said, to attain accuracies higher than traditional methods, deep learning requires a lot of data. That makes it a good candidate for data processing in big data applications. Naturally, they consume large amounts of memory, but Java cannot access arrays larger that can be indexed with a 32-bit `int` variable. This is an inherit limitation of the JVM. Given that Hadoop on Java is the de facto standard when it comes to big data applications, it makes sense to have a solution to that limitation. To support 64-bit indexing, we have thus extended the `position`, `limit`, and `capacity` fields of the [`Pointer`](http://bytedeco.org/javacpp/apidocs/org/bytedeco/javacpp/Pointer.html) class to `long`. Moreover, since standard NIO buffers do not support `long` indexing, we provide a new backend for the [`indexer`](http://bytedeco.org/javacpp/apidocs/org/bytedeco/javacpp/indexer/package-summary.html) package using `sun.misc.Unsafe`. Indexing memory with `long` variables represents a fundamental shift in the API, so it might break some existing code, but nothing too dramatic, we hope. On the brighter side, performance on 64-bit architectures is not affected.

[`Indexer`](http://bytedeco.org/javacpp/apidocs/org/bytedeco/javacpp/indexer/Indexer.html) also now implements `AutoCloseable`, to obtain the same benefit as with `Pointer` and try-with-resources constructs. For applications that cannot take advantage of this for memory management purposes, `Pointer` now also tracks the amount of memory allocated as reported by the `capacity` field. This does not work for most native libraries, more work would be required to query memory consumption from the operating system, but it works when allocating arrays of simple types with `allocateArray()`. Once memory consumption tracked this way reaches `Pointer.maxBytes`, the allocator will do its best to reclaim memory by calling `System.gc()`, waiting a bit, and retrying a few times in a loop.

That about covers the essential changes in this release, but other things have been fixed and updated too, so we invite you to check the changelogs and to contact us through the [mailing list from Google Groups](http://groups.google.com/group/javacpp-project), [issues on GitHub](https://github.com/bytedeco/javacpp/issues), or [the chat room at Gitter](https://gitter.im/bytedeco/javacpp), for any questions that you may have. Together, let's make the future happen!
